// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: location.sql

package db

import (
	"context"
	"database/sql"
)

const createUserLocation = `-- name: CreateUserLocation :execresult
INSERT INTO users_location (
    uid,
    latitude,
    longitude,
    altitude,
    category,
    fullname
) VALUES (
    ?, ?, ?, ?, ?, ?
)
`

type CreateUserLocationParams struct {
	Uid       string          `json:"uid"`
	Latitude  sql.NullFloat64 `json:"latitude"`
	Longitude sql.NullFloat64 `json:"longitude"`
	Altitude  sql.NullFloat64 `json:"altitude"`
	Category  string          `json:"category"`
	Fullname  string          `json:"fullname"`
}

func (q *Queries) CreateUserLocation(ctx context.Context, arg CreateUserLocationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUserLocation,
		arg.Uid,
		arg.Latitude,
		arg.Longitude,
		arg.Altitude,
		arg.Category,
		arg.Fullname,
	)
}

const getUserLocation = `-- name: GetUserLocation :one
SELECT id, uid, category, fullname, latitude, longitude, altitude, timestamp FROM users_location
WHERE uid = ?
LIMIT 1
`

func (q *Queries) GetUserLocation(ctx context.Context, uid string) (UsersLocation, error) {
	row := q.db.QueryRowContext(ctx, getUserLocation, uid)
	var i UsersLocation
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Category,
		&i.Fullname,
		&i.Latitude,
		&i.Longitude,
		&i.Altitude,
		&i.Timestamp,
	)
	return i, err
}

const getUserLocationByID = `-- name: GetUserLocationByID :one
SELECT id, uid, category, fullname, latitude, longitude, altitude, timestamp FROM users_location
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetUserLocationByID(ctx context.Context, id int32) (UsersLocation, error) {
	row := q.db.QueryRowContext(ctx, getUserLocationByID, id)
	var i UsersLocation
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Category,
		&i.Fullname,
		&i.Latitude,
		&i.Longitude,
		&i.Altitude,
		&i.Timestamp,
	)
	return i, err
}

const getUserLocations = `-- name: GetUserLocations :many
SELECT id, uid, category, fullname, latitude, longitude, altitude, timestamp FROM users_location
LIMIT ?
`

func (q *Queries) GetUserLocations(ctx context.Context, limit int32) ([]UsersLocation, error) {
	rows, err := q.db.QueryContext(ctx, getUserLocations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsersLocation{}
	for rows.Next() {
		var i UsersLocation
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Category,
			&i.Fullname,
			&i.Latitude,
			&i.Longitude,
			&i.Altitude,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLocationsByCategory = `-- name: GetUserLocationsByCategory :many
SELECT id, uid, category, fullname, latitude, longitude, altitude, timestamp FROM users_location
WHERE category = ?
LIMIT ?
`

type GetUserLocationsByCategoryParams struct {
	Category string `json:"category"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) GetUserLocationsByCategory(ctx context.Context, arg GetUserLocationsByCategoryParams) ([]UsersLocation, error) {
	rows, err := q.db.QueryContext(ctx, getUserLocationsByCategory, arg.Category, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsersLocation{}
	for rows.Next() {
		var i UsersLocation
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Category,
			&i.Fullname,
			&i.Latitude,
			&i.Longitude,
			&i.Altitude,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserLocation = `-- name: UpdateUserLocation :execresult
UPDATE users_location
SET
    latitude = ?,
    longitude = ?,
    altitude = ?,
    timestamp = ?
WHERE uid = ?
`

type UpdateUserLocationParams struct {
	Latitude  sql.NullFloat64 `json:"latitude"`
	Longitude sql.NullFloat64 `json:"longitude"`
	Altitude  sql.NullFloat64 `json:"altitude"`
	Timestamp sql.NullTime    `json:"timestamp"`
	Uid       string          `json:"uid"`
}

func (q *Queries) UpdateUserLocation(ctx context.Context, arg UpdateUserLocationParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateUserLocation,
		arg.Latitude,
		arg.Longitude,
		arg.Altitude,
		arg.Timestamp,
		arg.Uid,
	)
}
